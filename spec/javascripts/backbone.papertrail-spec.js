// Generated by CoffeeScript 1.3.1
(function() {

  describe("Backbone.PaperTrail", function() {
    var book, edit1, edit2, edit3;
    book = null;
    edit1 = {
      title: 'The next Great American Novel',
      pages: 350
    };
    edit2 = {
      title: 'The next Great American Website',
      price: 3
    };
    edit3 = {
      title: 'The next Great American JS library',
      author: 'Uncle Sam',
      price: 4
    };
    beforeEach(function() {
      return book = new Backbone.PaperTrail(edit1);
    });
    describe("restoring to original state", function() {
      it("should restore to it's original state", function() {
        book.store().set(edit2);
        book.store().set(edit3);
        book.restore();
        return expect(book.attributes).toEqual(edit1);
      });
      return it("should have on effect if there are no previous edits", function() {
        book.restore();
        return expect(book.attributes).toEqual(edit1);
      });
    });
    describe("rolling back to previous state(s)", function() {
      it("should rollback to it's prevois state", function() {
        var edit1And2;
        book.store().set(edit2);
        book.store().set(edit3);
        book.rollback();
        edit1And2 = _.extend({}, edit1, edit2);
        return expect(book.attributes).toEqual(edit1And2);
      });
      it("should rollback multiple times", function() {
        book.store().set(edit2);
        book.store().set(edit3);
        book.rollback(2);
        return expect(book.attributes).toEqual(edit1);
      });
      return it("should rollback to first possible state if distance excedes available states", function() {
        book.store().set(edit2);
        book.store().set(edit3);
        book.rollback(9);
        return expect(book.attributes).toEqual(edit1);
      });
    });
    describe("edits", function() {
      it("should keep the eidts array updated to reflect number of edits", function() {
        book.store().set(edit2);
        book.store().set(edit3);
        expect(book.edits().length).toBe(2);
        book.rollback();
        return expect(book.edits().length).toBe(1);
      });
      it("should return false is it hasn't been edited", function() {
        return expect(book.wasEdited()).toBe(false);
      });
      return it("should return true if it has been edited", function() {
        book.store().set(edit2);
        return expect(book.wasEdited()).toBe(true);
      });
    });
    return describe("retrieving prior attributes", function() {
      it("should give you the previous attributes", function() {
        book.store().set(edit2);
        return expect(book.priorAttributes()).toEqual(edit1);
      });
      it("should give you the previous attributes multiple steps back", function() {
        book.store().set(edit2);
        book.store().set(edit3);
        return expect(book.priorAttributes({
          distance: 2
        })).toEqual(edit1);
      });
      it("should be falsy if no previous attributes", function() {
        return expect(book.priorAttributes()).toBeFalsy();
      });
      it("should return a specified prior attribute", function() {
        book.store().set(edit2);
        book.store().set(edit3);
        return expect(book.prior('title')).toBe(edit2.title);
      });
      it("should return a specified prior attribute multiple levels back", function() {
        book.store().set(edit2);
        book.store().set(edit3);
        return expect(book.prior('title', {
          distance: 2
        })).toBe(edit1.title);
      });
      return it("should be falsy when no prior attribute", function() {
        book.store().set(edit2);
        return expect(book.prior('price')).toBeFalsy();
      });
    });
  });

}).call(this);
